# El Tidyverso {#tidyverso}

## Paquetes necesarios para este capítulo

Para este capitulo necesitas tener instalado el paquete *tidyverse*

En este capítulo se explicará qué es el paquete *tidyverse* [@Wickhamtidyverse] y cuales son sus componentes, ya demás veremos las funciones del paqute *tidyr* [@Wickhamtidy], con sus dos funciones `gather` y `spread`.

Dado que este libro es un apoyo para el curso BIO4022, esta clase del curso puede también ser seguida en este [link](https://derek-corcoran-barrios.github.io/Clase3/Clase3Hadleyverso). El video de la clase se encontrará disponible en este link.

## El tidiverso

El tidiverso se refiere al paquete [tidiverse](https://www.tidyverse.org/), el cual es una colección de paquetes coehrentes, que tienen una gramática, filosofía y estructura similar. Todos se basan el la idea de tidy data propuesta por Hadley Wickham [@wickham2014tidy]. Los paquetes que forman parte del tidyverso son:

* readr (ya la estamos usando)
* dplyr (Clase anterior)
* tidyr (Hoy)
* ggplot2 (Próxima clase)
* purrr (En clase sobre loops)
* forcats (Para variables categóricas)
* stringr (Para carácteres, Palabras)

### readr

El paquete *readr* [@Wickhamreadr] tiene como función el leer y exportar archivos. En general nosotros usaremos archivos del tipo *csv*. Para este tipo de archivos, *readr* tiene la función `read_csv`. Para exportar un archivo ocupamos la función `write_csv`. Ambas funciones son 10 veces más rápidas que las versiones de r base. Para más información sobre este revisar su [página oficial](https://readr.tidyverse.org/).

### dplyr

Este paquete sirve para modificar variables, los detalles de este paquete los vemos en el capítulo \@ref(tidydata). Los cinco verbos principales que tiene son `mutate` para generar nuevas variables, que vienen de variables ya existentes, `select` para seleccionar variables basadas en su nombre, `filter` para seleccionar filas de acuerdo a si cumplen o no con condiciones en una o mas variables, `summarize` para resumir las variables, y `arrange` para reordenar las filas de acuerdo a alguna variable. Para más información sobre este paquete revisar su [página oficial](https://dplyr.tidyverse.org/).

### tidyr

Con solo dos funciones, `gather` y `spread`, el paquete *tidyr* [@Wickhamtidy], tiene como finalidad el tomar bases de datos no tidy, y transformalas en tidy. Para esto, `gather` transforma tablas anchas en largas y `spread` transforma tablas anchas en larga. En este capítulo explicaremos en más detalle estos dos verbos. Para más información sobre este paquete revisar su [página oficial](https://tidyr.tidyverse.org/).

### ggplot2

Una vez que una base de datos está en formato tidy, podemos usar *ggplot2* [@Wickhamggplot] para visualizar estos datos, categóricos, continuos e incluso espaciales en conjunto con el pagquete *sf*. Este paquete es el más antiguo del *tidyverse*, y por ello posee una gramática un poco diferente. Hablaremos mas de este paquete en el capítulo \@ref(visualizacion). Por ahora si quieres aprender más sobre *ggplot2* puedes ver su [página oficial](https://ggplot2.tidyverse.org/)

### purrrr

*Purrr* [@HenryPurrr] permite formular loops de una forma mas sencilla e intuitiva que los for loops. Utilizando sus funciones `map`, `map2`, `walk` y `reduce` podemos realizar loops dentro de la gramática del tidiverse, trabajaremos en este paquete en el capítulo \@ref(loops). Como siempre puedes encontras más información en su [página oficial](https://purrr.tidyverse.org/)

### forcats

Trabajar con factores, es una de las labores mas complejas en R, es por eso que se creó el paquete *forcats* [@Wickhamforcats]. Si bién no hay un capítulo en este libro en el cuál trabajemos exclusivamente con este paquete, usaremos al menos una funcion en el capítulo \@ref(visualizacion)

### stringr

El modíficar variables de texto para hacer que las variables tengan sentido humano es algo muy importante, para este tipo de modificaciónes utilizamos el paquete *stringr* [@Wickhamstringr]. En este capítulo para algunos ejercicios introduciremos algunas funcionalidades de este paquete. para mas información revisar su [página oficial](https://stringr.tidyverse.org/). 

## tidyr

Este paquete como ya fue explicado en la sección anterior, solo posee dos funciones, `gather` y `spread`, las cuales sirven para pasar de tablas anchas a largas y viceversa, pero ¿qué significa que una tabla sea larga o ancha?

Tomemos por ejemplo la tabla \@ref(tab:TablasAnchas) vemos a la izquerda una tabla ancha y a la izquerda una tabla larga.

```{r TablasAnchas, echo = FALSE}
knitr::kable(
  list(
    (iris[c(1, 51, 101), ] %>% select(contains("Petal"), Species)),
    tidyr::gather((iris[c(1, 51, 101), ] %>% select(contains("Petal"), Species)),key = flower_att, value = measurement, -Species)
  ),
  caption = 'Tabla ancha y larga.', booktabs = TRUE, row.names = FALSE)
```

### gather

Esta funcion nos permite pasar de una tabla ancha a una larga. En muchos casos esto es necesario para generar una base de datos *tidy*, y en otras ocaciones es importante para generación de gráficos que necesitamos tal como veremos en el capítulo \@ref(visualizacion). En esta función partimos con un data frame, y luego tenemos 3 argumentos, en el primero `key`, ponemos el nombre de la variable que va a llevar como observaciones los nombres de las columnas; luego en el argumento *value*, ponemos el nombre de la columna que llevará los valores de cada columna al transformarse en una columna larga; Por último hay un último argumento (sin nombre), en el cual ponemos las columas que queremos que sean "*alargadas*", o, con un signo negativo, las que no queremos que sean parte de esta transformación. Todo esto quedará mas claro en el siguiente ejemplo.

#### Ejemplo de los censos

Supongamos que un estudiante de biología va a realizar un censo en un parque nacional por tres días y genera la siguiente tabla (el código a continuación es el que permite generar el data frame obervado en la tabla \@ref(tab:Censo))

```{r}
df_cuentas <- data.frame(
  dia = c("Lunes", "Martes", "Miercoles"),
  Lobo = c(2, 1, 3),
  Liebre = c(20, 25, 30),
  Zorro = c(4, 4, 4)
)
```

```{r Censo, echo = FALSE}
knitr::kable(df_cuentas,
  caption = 'Cuantos organismos se detectaron de cada especie en 3 días.', booktabs = TRUE, row.names = FALSE)
```

Claramente esta base de datos no es tidy, ya que deberíamos tener una columna para a variable día, otra para especie y por último una para la abundancia de cada especie en cadad día, antes de mostrar como realizaríamos esto con `gather`, veamos sus efectos para entenderlo mejor. La forma más básica de usar esta función sería el solo darle un nombre a la columna *key* (que tendrá el nombre de las columnas) y otro a *value*, que tendría el valor de las celdas. Veamos que ocurre si hacermos eso en el siguiente codigo y tabla \@ref(tab:Larga1).

```{r, warning=FALSE, message=FALSE}
library(tidyverse)
DF_largo <- df_cuentas %>% gather(key = Columnas, value = Valores)
```

```{r Larga1, echo = FALSE}
knitr::kable(DF_largo,
  caption = 'Cuantos organismos se detectaron de cada especie en 3 días.', booktabs = TRUE, row.names = FALSE)
```

Como vemos en la tabla \@ref(tab:Larga1), en la columna llamada *Columnas*, tenemos solo los nombres de las columnras de la tabla \@ref(tab:Censo), y en la columna *Valores*, tenemos los valores encontrados en la tabla \@ref(tab:Censo), sin embargo, para tener las tres columnas que desearíamos tener (día, especie y  abundancia), necesitamos que la variable día no participe de este "*alargamiento*", para esto lo que haríamos sería los siguiente:

```{r, warning=FALSE, message=FALSE}
DF_largo <- df_cuentas %>% gather(key = Columnas, value = Valores, -dia)
```

Al agregar `-día` como tercer argumento quitamos esa variable del día en el "*alargamiento*", en ese caso obtenemos la tabla \@ref(tab:Larga2), ahora solo nos falta arreglar los nombres. 

```{r Larga2, echo = FALSE}
knitr::kable(DF_largo,
  caption = 'Cuantos organismos se detectaron de cada especie en 3 días.', booktabs = TRUE, row.names = FALSE)
```

Para cambiar los nombres de las columnas que nos faltan, solo cambiamos los valores de los argumentos `key` y `value` como se vé a continuación y en la tabla \@ref(tab:Larga3).

```{r, warning=FALSE, message=FALSE}
DF_largo <- df_cuentas %>% gather(key = Especie, value = Abundancia, -dia)
```

```{r Larga3, echo = FALSE}
knitr::kable(DF_largo,
  caption = 'Cuantos organismos se detectaron de cada especie en 3 días.', booktabs = TRUE, row.names = FALSE)
```