# Visualización de datos {#visualizacion}

## Paquetes necesarios para este capítulo

Para este capítulo necesitas tener instalado el paquete *tidyverse*.

En este capítulo se explicará qué es el paquete *ggplot2* [@Wickhamggplot] y como podemos utilizarlo para visualizar datos.

Dado que este libro es un apoyo para el curso BIO4022, esta clase puede también ser seguida en este [link](https://derek-corcoran-barrios.github.io/Clase4/Clase4Visualizacion). El video de la clase se encontrará disponible en este [link]

## El esqueleto

El esqueleto de una visualización usando *ggplot2* es la siguiente

```{r, eval = FALSE}
ggplot(data.frame, aes(nombres_de_columna)) + geom_algo(argumentos, aes(columnas)) + theme_algo()
```

Como ejemplo para discutir usaremos el siguiente código que genera la figura \@ref(fig:ejemplo1-ggplot):

```{r ejemplo1-ggplot, fig.cap='Gráfico en el cual gráficamos los quilates de diamantes versus su precio, con el corte del diamante representado por el color', out.width='80%', fig.asp=.75, fig.align='center', echo = TRUE, cache = TRUE}
library(tidyverse)
data("diamonds")
ggplot(diamonds, aes(x = carat, y=price)) + geom_point(aes(color = cut)) + theme_classic()
```


En este caso general, lo primero que ponemos después de ggplot es el data.frame desde el cuál graficaremos algo, en el ejemplo de la figura \@ref(fig:ejemplo1-ggplot) usamos la base de datos *diamonds* del paquete *ggplot2* [@Wickhamggplot]. Luego dentro de `aes` ponemos las columnas que graficaremos como *x* y/o *y*, en nuestro ejemplo dentro de aes ponemos como eje *x* los kilates de los diamantes (caret) y como *y* el precio de los mismos (price). La necesidad de poner `aes` en ggplot2 (algo que no había sido necesario cuando usamos *dplyr* o *tidyr*).

## Por que usamos aes() y +

Al ser el primer paquete creado en el tidyverse, *ggplot2* tiene un par de convenciones distintas, por un lado cada vez que usamos el nombre de una columna que esta en un data frame usamos debemos usarlo dentro de la función `aes`

Además, cuando se creo el paquete *ggplot2* no existia el pipeline (`%>%`), por lo que se utilizaba el signo `+` con la misma función

## geom_algo

Luego de especificar una base de datos, esto viene seguido de un `geom_algo`, esto nos indicará que tipo de gráfico usaremos, estos pueden ser combinados como veremos en ejemplos futuros

### Una variable categórica una continua

Primero veremos algunos de los *geom* que podemos utilizar con una variable categórica y una continua

#### geom_boxplot

En la figura \@ref(fig:boxplot), generado a partir del código a continuacón con la base de datos iris presente en `R` [@anderson1935irises].  

```{r boxplot, fig.cap='Boxplot que representa los largos del sépalo de tres especies del género Iris', out.width='80%', fig.asp=.75, fig.align='center', echo = TRUE, cache = TRUE}
data("iris")
ggplot(iris, aes(x = Species, y = Sepal.Length)) + geom_boxplot()
```

Los boxplots muestran una linea gruesa central (la mediana), una caja, que delimita el primer y tercer cuartil, y los bigotes, los cuales se extienden hasta los valores extremos. A menos que estos esten por sobre 1.5 veces la distance entre el primer y tercer cuartil, en cuyo caso se consideran outlyers, y estos son representados por puntos. En la figura \@ref(fig:boxplot), solo *Iris virginica* presenta un outlayer en cuanto a las medidas del largo del sepalo.

Los boxplots, como todos los gráficos pueden ser personalizados usando otros argumentos, los cuales son detallados en la sección \@ref(argumentos), pero en los ejemplos que mostraremos en esta sección los iremos introduciendo de a poco. Si quisieramos por ejemplo que el color de las cajas del *boxplot* fuera deacuerdo a la especie, cambiamos el llenado (**fill**) de la caja, como vemos en el siguiente ejemplo y figura \@ref(fig:boxplot2)

```{r boxplot2, fig.cap='Boxplot que representa los largos del sépalo de tres especies del género Iris, en este caso el color de la caja representa la especie', out.width='80%', fig.asp=.75, fig.align='center', echo = TRUE, cache = TRUE}
ggplot(iris, aes(x = Species, y = Sepal.Length)) + geom_boxplot(aes(fill = Species))
```

Dos cosas a notar en este ejemplo, por un lado la leyenda se genera de forma automática, y por otro lado, vemos que es necesario poner *Species* dentro de `aes`, esto es debido a que Species es una columna y como se explicó al principio de este capítulo, todas las columnas deben ser incuidas dentro de la función `aes` para poder ser referenciadas.

#### geom_jitter

Utilizando la misma base de datos, podemos crear un gráfico del tipo *jitter*, en este caso hay un punto por cada observación, lo cual puede ayudar a entender mejor los datos que tenemos.

```{r jitter, fig.cap='jitter plot que representa los largos del sépalo de tres especies del género Iris, en este caso el color de los puntos representan la especie', out.width='80%', fig.asp=.75, fig.align='center', echo = TRUE, cache = TRUE}
ggplot(iris, aes(x = Species, y = Sepal.Length)) + geom_jitter(aes(color = Species))
```

En la figura \@ref(fig:jitter) vemos los mismos datos, que en la figura \@ref(fig:boxplot), el agregar el `color = Species` dentro del `aes` nos permite que el color de cada punto este determinado por la especie a la que pertenece.

#### Otros geom categoricos

Otros geom categóricos que podemos explorar con esta base de datos son:

* geom_violin
* geom_bar
* geom_col

## Combinando geoms

Uno puede combinar geoms para formar un grafico combinado, por ejemplo podriamos generar un grafico con un boxplot y un jitter plot como vemos en la figura \@ref(fig:boxjitter)

```{r boxjitter, fig.cap='Boxplot y jitter plot combinados que representa los largos del sépalo de tres especies del género Iris.', out.width='80%', fig.asp=.75, fig.align='center', echo = TRUE, cache = TRUE}
ggplot(iris, aes(x = Species, y = Sepal.Length)) + geom_boxplot() + geom_jitter(aes(color = Species))
```

### El orden importa

Si bien se pueden combinar los geom, el orden de estos importa, ya que *ggplot2* genera las figuras por capas, esto es ilustrado en la figura  \@ref(fig:jitterbox), en la cual al crear primero el jitter y luego el boxplot, las cajas del boxplot tapan los puntos, a diferencia de la figura \@ref(fig:boxjitter)

```{r jitterbox, fig.cap='Boxplot y jitter plot combinados que representa los largos del sépalo de tres especies del género Iris, en este caso al llamar al jitter antes del boxplot, las cajas tapan los puntos.', out.width='80%', fig.asp=.75, fig.align='center', echo = TRUE, cache = TRUE}
ggplot(iris, aes(x = Species, y = Sepal.Length)) + geom_jitter(aes(color = Species)) + geom_boxplot()
```

### Una variable categórica una continua

Algunos de los geoms que podemos usar para dos variables continuas son:

* geom_point
* geom_smooth
* geom_line
* geom_hex
* geom_rug

Ahora veremos algunas de ellas:

#### geom_point

Este geom es el que nos permite hacer un gráfico de dispersión en R. Para esto tenemos que poner como x e y en ggplot variables continuas y agragar la función `geom_point` como vemos en el siguiente código y en la figura \@ref(fig:scatter).


```{r scatter, fig.cap='Gráfico en el cual vemos el peso de pollos en el tiempo', out.width='80%', fig.asp=.75, fig.align='center', echo = TRUE, cache = TRUE}
data("ChickWeight")
ggplot(ChickWeight, aes(x = Time, y= weight)) + geom_point()
```

Si quisieramos que el color de cada punto estuviera separado por peso, podríamos agregarle `aes(color = Diet)` a geom_point, pero deberíamos transformar Diet en factor, ya sea antes de usar ggplot o dentro de ggplot tal como vemos en el siguiente código y en la figura \@ref(fig:scatterColor).

```{r scatterColor, fig.cap='Gráfico en el cual vemos el peso de pollos en el tiempo, con colores distintos según el tipo de dieta', out.width='80%', fig.asp=.75, fig.align='center', echo = TRUE, cache = TRUE}
data("ChickWeight")
ggplot(ChickWeight, aes(x = Time, y= weight)) + geom_point(aes(color = factor(Diet)))
```

#### geom_smooth y stat_smooth

##### geom_smooth
Estas funciones nos permiten generar lineas de tendencias con intervalos de confianza para estas lineas, así si quisieramos ver lineas de tendencias para nuestro scatterplot, dependiendo de la dieta, usaríamos el siguiente código el cual nos da la figura \@ref(fig:scatterLoess).

```{r scatterLoess, fig.cap='Gráfico en el cual vemos el peso de pollos en el tiempo, con colores distintos según el tipo de dieta, con lineas de tendencia e intervalos de confianza basados en el método loess', out.width='80%', fig.asp=.75, fig.align='center', echo = TRUE, cache = TRUE}
ggplot(ChickWeight, aes(x = Time, y= weight)) + geom_point(aes(color = factor(Diet))) + geom_smooth(aes(fill = factor(Diet)))
```

Por defeccto, la función `geom_smooth` generará una tendencia basada en *loess*, lo cual es una correlación local. En general, es mejor hacer una linea de tendencia basado en modelos que uno puede explicar mejor como un modelo lineal. Para esto, cambiamos el argumento method a lm como en el siguiente código y la figura \@ref(fig:scatterLM).

```{r scatterLM, fig.cap='Gráfico en el cual vemos el peso de pollos en el tiempo, con colores distintos según el tipo de dieta, con lineas de tendencia e intervalos de confianza basados en modelos lineales', out.width='80%', fig.asp=.75, fig.align='center', echo = TRUE, cache = TRUE}
ggplot(ChickWeight, aes(x = Time, y= weight)) + geom_point(aes(color = factor(Diet))) + geom_smooth(aes(fill = factor(Diet)), method = "lm")
```

##### stat_smooth

La función `stat_smooth` es más flexible que `geom_smooth`. La gran diferencia es que nos permite incluir una formula para expresar la relación entre $x$ e $y$, por ejemplo, si pensaramos que en el caso de la base de datos `ChickWeight` la relación entre el peso y el tiempo se expresa mejor con una ecuación cuadrática (ver ecuacación \@ref(eq:quad)) generaríamos el siguiente código que genera la figura \@ref(fig:scatterQuad).

```{r scatterQuad, fig.cap='Gráfico en el cual vemos el peso de pollos en el tiempo, con colores distintos según el tipo de dieta, con lineas de tendencia e intervalos de confianza basados en modelos lineales con una relación cuadrática', out.width='80%', fig.asp=.75, fig.align='center', echo = TRUE, cache = TRUE}
ggplot(ChickWeight, aes(x = Time, y= weight)) + geom_point(aes(color = factor(Diet))) + stat_smooth(aes(fill = factor(Diet)), method = "lm", formula = y ~ x + I(x^2))
```

\begin{equation} 
  y = \beta_2 x^2 + \beta_1 x + c
  (\#eq:quad)
\end{equation} 


## Argumentos {#argumentos}
